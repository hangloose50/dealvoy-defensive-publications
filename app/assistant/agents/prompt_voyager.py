#!/usr/bin/env python3
"""
üß† PromptVoyager - Auto-generates smart .prompt files
Analyzes code context, usage patterns, and app behavior to create optimized prompts
"""

import os
import json
from datetime import datetime
from pathlib import Path

class PromptVoyager:
    def __init__(self, project_path="."):
        self.project_path = Path(project_path)
        self.prompts_dir = self.project_path / "app" / "prompts"
        self.prompts_dir.mkdir(parents=True, exist_ok=True)
        
    def analyze_codebase(self):
        """Scan codebase for patterns that need prompts"""
        patterns = []
        
        # Look for common AI/ML usage patterns
        for py_file in self.project_path.rglob("*.py"):
            try:
                with open(py_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    
                # Detect AI/prompt usage
                if any(keyword in content.lower() for keyword in 
                      ['openai', 'claude', 'gpt', 'prompt', 'ai_', 'llm']):
                    patterns.append({
                        'file': str(py_file),
                        'type': 'ai_integration',
                        'needs_prompt': True
                    })
                    
                # Detect scraping/vision patterns  
                if any(keyword in content.lower() for keyword in
                      ['scraper', 'vision', 'ocr', 'image', 'tesseract']):
                    patterns.append({
                        'file': str(py_file),
                        'type': 'vision_processing', 
                        'needs_prompt': True
                    })
                    
            except Exception as e:
                continue
                
        return patterns
    
    def generate_prompt_templates(self):
        """Generate optimized prompt templates"""
        templates = {
            "product_identification": {
                "role": "You are an expert product identification assistant for Dealvoy.",
                "context": "Analyze product images, barcodes, and text to identify items for price comparison.",
                "instructions": [
                    "Extract product title, brand, UPC/barcode if visible",
                    "Identify product category and key specifications", 
                    "Return structured JSON with confidence scores",
                    "Flag any unclear or ambiguous elements"
                ],
                "format": "JSON with fields: title, brand, upc, category, confidence"
            },
            
            "price_analysis": {
                "role": "You are a pricing analysis expert for deal discovery.",
                "context": "Compare prices across multiple retailers to find arbitrage opportunities.",
                "instructions": [
                    "Calculate price deltas and ROI percentages",
                    "Identify significant price drops or opportunities",
                    "Consider shipping costs and fees in calculations",
                    "Flag deals that meet minimum ROI thresholds"
                ],
                "format": "Structured analysis with recommendations"
            },
            
            "ocr_processing": {
                "role": "You are an OCR text correction and enhancement specialist.",
                "context": "Clean and structure text extracted from product images and documents.",
                "instructions": [
                    "Correct common OCR errors and artifacts",
                    "Extract structured data from unstructured text",
                    "Identify and validate product codes and prices",
                    "Return clean, structured output"
                ],
                "format": "Clean text with extracted structured data"
            }
        }
        
        return templates
    
    def save_prompts(self, templates):
        """Save prompt templates to files"""
        saved_files = []
        
        for name, template in templates.items():
            prompt_file = self.prompts_dir / f"{name}.prompt"
            
            prompt_content = f"""# {name.replace('_', ' ').title()} Prompt
# Generated by PromptVoyager on {datetime.now().isoformat()}

## Role
{template['role']}

## Context  
{template['context']}

## Instructions
"""
            
            for instruction in template['instructions']:
                prompt_content += f"- {instruction}\n"
                
            prompt_content += f"\n## Output Format\n{template['format']}\n"
            
            with open(prompt_file, 'w', encoding='utf-8') as f:
                f.write(prompt_content)
                
            saved_files.append(str(prompt_file))
            
        return saved_files
    
    def run(self):
        """Main execution function"""
        print("üß† [PromptVoyager] Analyzing codebase for prompt opportunities...")
        
        # Analyze existing code
        patterns = self.analyze_codebase()
        print(f"   Found {len(patterns)} patterns requiring prompts")
        
        # Generate templates
        print("üß† [PromptVoyager] Generating optimized prompt templates...")
        templates = self.generate_prompt_templates()
        
        # Save prompts
        saved_files = self.save_prompts(templates)
        
        print("‚úÖ PromptVoyager: Generated prompts:")
        for file_path in saved_files:
            print(f"   üìù {file_path}")
            
        # Save analysis report
        report_file = self.prompts_dir / "analysis_report.json"
        with open(report_file, 'w') as f:
            json.dump({
                'timestamp': datetime.now().isoformat(),
                'patterns_found': patterns,
                'prompts_generated': list(templates.keys()),
                'files_created': saved_files
            }, f, indent=2)
            
        print(f"   üìä Analysis report: {report_file}")
        print("üß† [PromptVoyager] Ready for AI-enhanced workflows!")

def run():
    """CLI entry point"""
    voyager = PromptVoyager()
    voyager.run()

if __name__ == "__main__":
    run()
